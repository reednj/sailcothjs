{"version":3,"sources":["../src/viewport.js"],"names":["Renderable","constructor","renderingFinished","positionType","zIndex","render","viewport","sinceLastFrame","ViewportObject","options","x","y","update","Viewport","element","sizingElement","autoRedraw","onRedraw","tick","waitingForFrame","lastFrameTime","renderQueueChanged","renderQueue","canvas","context","getContext","updateDimensions","window","addEventListener","autosize","_width","width","_scale","_height","height","parentSize","clientWidth","clientHeight","forEach","o","onResize","start","refresh","requestAnimationFrame","redraw","bind","stop","clear","filter","currentTime","Date","renderObjects","renderObject","add","startRendering","push","sort","a","b","clearRect","getObjectCount","length","getCenter","Math","round","WorldViewport","origin","staticQueue","worldQueue","setScale","n","scale","updateQueues","save","translate","i","restore","objectVisible","setOrigin","getOrigin","setCenter","_center","_bounds","center","bounds","top","left","bottom","right","pointVisible","getBounds","undefined"],"mappings":"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","file":"viewport.js","sourcesContent":["// @flow\n\ntype Point = {x:number, y:number}\ntype Rect = {x:number, y:number, width:number, height:number}\n\nexport interface IRenderable {\n    viewport:Viewport;\n\trenderingFinished:boolean;\n\tpositionType: \"world\" | \"static\";\n    render(viewport:Viewport, sinceLastFrame:number):void;\n}\n\nexport class Renderable {\n\tviewport:Viewport;\n\trenderingFinished:boolean;\n\tpositionType: \"world\" | \"static\";\n\tzIndex:number;\n\tconstructor() {\n\t\tthis.renderingFinished = false;\n\t\tthis.positionType = \"world\";\n\t\tthis.zIndex = 100;\n\t}\n\n\trender(viewport:Viewport, sinceLastFrame:number) {\n\t}\n}\n\nexport class ViewportObject extends Renderable {\n    x:number;\n\ty:number;\n\twidth:?number;\n\theight:?number;\n    constructor(options:{x:number,y:number}) {\n\t\tsuper();\n\t\tthis.x = options.x;\n\t\tthis.y = options.y;\n    }\n\n    render(viewport:Viewport, sinceLastFrame:number) {\n        this.update(sinceLastFrame);\n    }\n\n    update(sinceLastFrame:number) {\n    }\n}\n\nexport class Viewport {\n    element:?HTMLCanvasElement;\n    options:Object;\n    tick:number;\n    waitingForFrame:boolean;\n    lastFrameTime:?Date;\n    renderQueueChanged:boolean;\n    renderQueue:Object[];\n    canvas:HTMLCanvasElement;\n    context:CanvasRenderingContext2D;\n    \n    _width:number;\n    _height:number;\n\t_scale:number;\n\t\n\t// if this is set to an element, the canvas will try to fill it\n\t// as much as possible when the window is resized\n\tsizingElement:?HTMLElement;\n\tconstructor(element:HTMLCanvasElement, options:Object) {\n\t\tthis.element = element;\n\t\tthis.sizingElement = options.sizingElement || null;\n        \n        this.options = options || {};\n      \tthis.options.autoRedraw = false;\n\t\tthis.options.onRedraw = this.options.onRedraw || function() {};\n\n\t\tthis.tick = 0;\n\t\tthis.waitingForFrame = false;\n\t\tthis.lastFrameTime = null;\n\n\t\tthis.renderQueueChanged = false;\n\t\tthis.renderQueue = [];\n\n\t\tthis.canvas = this.element;\n\t\tthis.context = this.canvas.getContext('2d');\n\t\tthis.updateDimensions();\n\n\t\tif(this.sizingElement) {\n\t\t\twindow.addEventListener('resize', () => this.autosize());\n\t\t\tthis.autosize();\n\t\t}\n\t}\n\n\tupdateDimensions() {\n\t\t// the canvas height and width properties actually call a function. We assign them\n\t\t// here to variables for speed reasons, as they might get accessed many times per\n\t\t// frame\n\t\tthis._width = this.canvas.width / (this._scale || 1.0);\n\t\tthis._height = this.canvas.height / (this._scale || 1.0);\n\t}\n\n\tautosize() {\n\t\tif(this.canvas && this.sizingElement) {\n\t\t\tvar parentSize = {\n\t\t\t\tx: this.sizingElement.clientWidth || 0,\n\t\t\t\ty: this.sizingElement.clientHeight || 0\n\t\t\t}\n\n\t\t\tthis.canvas.width = parentSize.x;\n\t\t\tthis.canvas.height = parentSize.y;\n\n\t\t\tthis.renderQueue.forEach(o => {\n\t\t\t\tif(typeof o.onResize == 'function') {\n\t\t\t\t\to.onResize(this._width, this._height, this);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.updateDimensions();\n\t\t}\n\t}\n\n\tstart() {\n\t\treturn this.refresh(true);\n\t}\n\n\trefresh(autoRedraw:boolean) {\n\t\tif(this.waitingForFrame === false && this.options.autoRedraw === false) {\n\t\t\trequestAnimationFrame(this.redraw.bind(this));\n\n\t\t\t// the waiting for frame flag makes sure that the frame will only be redrawn once\n\t\t\t// if mulitple requests are made on the same canvas before it gets a chance to draw\n\t\t\tthis.waitingForFrame = true;\n\n\t\t\tif(autoRedraw === true) {\n\t\t\t\tthis.options.autoRedraw = autoRedraw;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n \t}\n\n\tstop() {\n\t\tthis.options.autoRedraw = false;\n\t\treturn this;\n\t}\n\n\tredraw() {\n\t\tthis.tick++;\n\t\tthis.waitingForFrame = false;\n\n\t\tthis.clear();\n\n\t\t// call the redraw event, so that the position of objects etc can be updated\n\t\tthis.options.onRedraw(this);\n\n\t\t// after the redraw event there might be some objects we dont want to render\n\t\t// anymore. So we get a list of them, and remove them from the render queue\n\t\tthis.renderQueue = this.renderQueue.filter(o => !o.renderingFinished);\n\n\t\t// we want to calulate the time since the last frame so that things can be animated consistantly\n\t\tvar currentTime = new Date();\n\t\tvar sinceLastFrame = currentTime - (this.lastFrameTime || currentTime);\n\t\tthis.lastFrameTime = currentTime;\n\n\t\tthis.renderObjects(this.renderQueue, sinceLastFrame);\n\n\t\tif(this.options.autoRedraw === true) {\n\t\t\trequestAnimationFrame(this.redraw.bind(this));\n\t\t}\n\n\t\tthis.renderQueueChanged = false;\n\t}\n\n\trenderObjects(renderQueue:IRenderable[], sinceLastFrame:number) {\n\t\trenderQueue.forEach(function(o) {\n\t\t\tthis.renderObject(o, sinceLastFrame);\n\t\t}.bind(this));\n\t}\n\n\trenderObject(o:IRenderable, sinceLastFrame:number) {\n\t\tif(o) {\n\t\t\to.render(this, sinceLastFrame);\n\t\t}\t\t\n\t}\n\n\tadd(o:IRenderable) {\n\t\treturn this.startRendering(o);\n\t}\n\n\tstartRendering(o:IRenderable) {\n    \tif(!o) {\n    \t\treturn;\n    \t}\n\n\t\t// the object has to have a render function for it to be added to the queue\n\t\tif(!o.render || typeof o.render != 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\t// re-adding the object resets the render finished flag\n\t\tif(o.renderingFinished === true) {\n\t\t\to.renderingFinished = false;\n\t\t}\n\n\t\t// if the object has a viewport variable that is not set yet, then we will set it\n\t\t// to the current one. Don't want to overwrite this though, because it is possible\n\t\t// for an object to belong to more than one viewport\n\t\tif(!o.viewport) {\n\t\t\to.viewport = this;\n\t\t}\n\n\t\t// if it has a resize method, then we fire that as well when it is added, so that\n\t\t// it can position itself etc\n\t\tif(typeof o.onResize == 'function') {\n\t\t\to.onResize(this._width, this._height, this);\n\t\t}\n\n\t\tthis.renderQueue.push(o);\n\t\tthis.renderQueueChanged = true;\n\n\t\t// now we need to sort the render queue by zindex to make sure it is rendered in the same order\n\t\tthis.renderQueue.sort(function(a, b) { return (a.zIndex || 1) - (b.zIndex || 1);});\n\n\t\treturn this;\n\t}\n\n\tclear() {\n\t\tthis.context.clearRect(0, 0, this._width, this._height);\n\t}\n\n\tgetObjectCount() {\n\t\treturn this.renderQueue.length;\n\t}\n\n\t// gets the center of the canvas in static co-ords\n\tgetCenter() {\n\t\treturn {\n\t\t\tx: Math.round(this._width / 2),\n\t\t\ty: Math.round(this._height / 2)\n\t\t};\n\t}\n}\n\nexport class WorldViewport extends Viewport {\n\torigin:Point;\n\tstaticQueue:IRenderable[];\n\tworldQueue:IRenderable[];\n\n\t_center:?Point;\n\t_bounds:?Rect;\n\n\tconstructor(element:HTMLCanvasElement, options:Object = {}) {\n\t\tsuper(element, options);\n\t\tthis.origin = this.options.origin || {x:0, y:0};\n\n\t\tthis.staticQueue = [];\n\t\tthis.worldQueue = [];\n\n\t\tthis._width = 0.0;\n\t\tthis._height = 0.0;\n\t\tthis._scale = 1.0;\n\t\tthis.updateDimensions();\n\t}\n\n\tsetScale(n:number) {\n\t\tif(n != null) {\n\t\t\tthis.context.scale(n, n);\n\t\t\tthis._scale = n;\n\t\t\tthis.updateDimensions();\n\t\t}\n\t}\n\n\tupdateQueues(renderQueue:IRenderable[]) {\n\t\tthis.staticQueue = renderQueue.filter(o => o.positionType != 'world');\n\t\tthis.worldQueue  = renderQueue.filter(o => o.positionType == 'world');\n\t}\n\n\trenderObjects(renderQueue:IRenderable[], sinceLastFrame:number) {\n\t\tif(this.renderQueueChanged === true) {\n\t\t\tthis.updateQueues(renderQueue);\n\t\t}\n\n\t\tthis.updateDimensions();\n\n\t\tthis.context.save();\n\t\tthis.context.translate(-this.origin.x, -this.origin.y);\n\t\t\n\t\tfor(var i=0; i < this.worldQueue.length; i++) {\n\t\t\tthis.renderObject(this.worldQueue[i], sinceLastFrame);\n\t\t}\n\n\t\tthis.context.restore();\n\n\t\t// this means that static objects will always render on top of the world ones\n\t\t// it would be difficult to fix this, but since this is mostly what we want anyway\n\t\t// lets just ignore this problem\n\t\tsuper.renderObjects(this.staticQueue, sinceLastFrame);\n\n\t}\n\n\t// calls the render method the object in the right way. If the renderable\n\t// has the position type set to world, then we check if the object is visible\n\t// before rendering, as well as calling any other aux functions.\n\t//\n\t// Statically positioned objects are rendered the same as before\n\trenderObject(o:IRenderable, sinceLastFrame:number) {\n\t\tif(o.positionType == 'world' && o instanceof ViewportObject) {\n\t\t\tif(this.objectVisible(o) && o.render) {\n\t\t\t\to.render(this, sinceLastFrame);\n\t\t\t}\n\t\t} else {\n\t\t\tsuper.renderObject(o, sinceLastFrame);\n\t\t}\n\t}\n\n\t// this sets the canvas (0,0) (in screen coords) to the x,y arguments\n\t// in world coordinates. Put another way, the x,y provided as arguments\n\t// will be the world coordinates of the top left corner of the canvas.\n\tsetOrigin(x:number, y:number) {\n\t\tthis.origin = {x: x, y: y};\n\t}\n\n\tgetOrigin():Point {\n\t\treturn this.origin;\n\t}\n\n\t// this is the same as setOrigin, but it uses the center of the canvas as the reference\n\t// instead of the top-left. x and y will be the world coordinates of the center of the \n\t// canvas\n\tsetCenter(x:number, y:number) {\n\t\tthis._center = null;\n\t\tthis._bounds = null;\n\t\tthis.setOrigin(x - Math.round(this._width / 2), y - Math.round(this._height / 2));\n\t}\n\n\tget center():Point {\n\t\treturn this._center = this._center || {\n\t\t\tx: this.origin.x + Math.round(this._width / 2),\n\t\t\ty: this.origin.y + Math.round(this._height / 2)\n\t\t};\n\t}\n\n\t// returns the bounds of the viewport in world coordinates\n\t// this is mainly used to decide if a given object is visible on the\n\t// canvas and should be rendered\n\tget bounds():Object {\n\t\treturn this._bounds = this._bounds || {\n\t\t\tx: this.origin.x,\n\t\t\ty: this.origin.y,\n\t\t\twidth: this._width,\n\t\t\theight: this._height,\n\t\t\ttop: this.origin.y,\n\t\t\tleft: this.origin.x,\n\t\t\tbottom: this.origin.y + this._height,\n\t\t\tright: this.origin.x + this._width\n\t\t};\n\t}\n\n\t//\n\t// assumes the object being passed has at least a 'getBounds' method, and if not\n\t// at least an x or y property so it can be evalulated as a point\n\t//\n\t// this will default to returning TRUE\n\t//\n\t// this gets called for every objet on every frame, so we should work on making it more\n\t// efficient...\n\t//\n\tobjectVisible(o:ViewportObject) {\n\t\tif(o.x == null || o.y == null)\n\t\t\treturn true;\n\n\t\tif(this.pointVisible(o.x, o.y))\n\t\t\treturn true;\n\n\t\tif((o.x - this.origin.x > this._width * 2) || (o.x - this.origin.x < -this._width))\n\t\t\treturn false;\n\n\t\tif((o.y - this.origin.y > this._height * 2) || (o.y - this.origin.y < -this._height))\n\t\t\treturn false;\n\n\t\tvar bounds:Rect;\n\t\tif(!o.getBounds) {\n\t\t\tif(o.x !== undefined && o.y !== undefined && o.width !== undefined && o.height !== undefined) {\n\t\t\t\tbounds = {\n\t\t\t\t\tx: o.x,\n\t\t\t\t\ty: o.y,\n\t\t\t\t\twidth: o.width || 0,\n\t\t\t\t\theight: o.height || 0\n\t\t\t\t};\n\t\t\t} else if(o.x !== undefined  && o.y !== undefined) {\n\t\t\t\treturn this.pointVisible(o.x, o.y);\n\t\t\t} else {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\tbounds = (o:any).getBounds();\n\t\t}\n\n\t\tif(!bounds.width || !bounds.height) {\n\t\t\t// either object has no width and height, or they are\n\t\t\t// undefined. Either way just evaluate the visibility as if it was a point\n\t\t\treturn this.pointVisible(bounds.x, bounds.y);\n\t\t} else {\n\t\t\t// we need to check the visibility of each corner of the bounds, if any is visible\n\t\t\t// then we say that the object is\n\t\t\treturn this.pointVisible(bounds.x, bounds.y) ||\n\t\t\t\tthis.pointVisible(bounds.x + bounds.width, bounds.y) ||\n\t\t\t\tthis.pointVisible(bounds.x, bounds.y + bounds.height) ||\n\t\t\t\tthis.pointVisible(bounds.x + bounds.width, bounds.y + bounds.height);\n\t\t}\n\t}\n\n\tpointVisible(x:number, y:number) {\n\t\treturn (x >= this.origin.x && x < this.origin.x + this._width) && (y >= this.origin.y && y < this.origin.y + this._height);\n\t}\n}\n"]}